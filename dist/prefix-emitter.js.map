{"version":3,"file":null,"sources":["../src/utils.ts","../src/es5-fallback.ts","../src/prefix-emitter.ts"],"sourcesContent":["﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\r\n/**\r\n * Remove first occurrence of given item from the array.\r\n * @param array Array\r\n * @param item any\r\n */\r\nexport function removeItem(array: any[], item: any): void {\r\n    const index = array.indexOf(item);\r\n    if (index > 0) {\r\n        array.splice(index, 1);\r\n    } else if (index === 0) {\r\n        array.shift();\r\n    }\r\n}\r\n\r\nfunction repeat(count: number, template: (i: number) => string, sep = \"\"): string {\r\n    const arr: any[] = [];\r\n    for (let i = 1; i <= count; ++i) {\r\n        arr.push(template(i));\r\n    }\r\n    return arr.join(sep);\r\n}\r\n\r\nfunction assign(target: Object, source: Object): void {\r\n    for (let k in source) {\r\n        if (source.hasOwnProperty(k)) {\r\n            target[k] = source[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Build new function from given one with injected logic at the beginning of function call.\r\n * @param target Function: target function\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport const decorateMethod: (target: Function, logic: Function) => Function = new Function(\"target\", \"logic\", `\r\n    switch (target.length) {${repeat(16, l => `\r\n        ${l < 16 ? `case ${l}` : `default`}: return function (${repeat(l, i => \"v\" + i, \", \")}) {\r\n            logic.apply(this, arguments);\r\n            return target.apply(this, arguments);\r\n        };`)}\r\n    }\r\n`) as any;\r\n\r\n/**\r\n * Build new constructor from given one with injected logic at the beginning of constructor call.\r\n * @param target Function: target constructor\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport function decorateClass(target: Function, logic: Function): Function {\r\n    // unique prefix for Function constructor for\r\n    // eliminate conflicts with `target` functions names\r\n    const pr = \"bvjxRy0LjL9D\";\r\n\r\n    // Code generation is used to preserve target's `.name` and `.length`\r\n    // It is about 30x slower than simple funciton wrapping\r\n    // But it is slill less than 5 microseconds per call\r\n    // So if you have 200 decorated classes it took less then 1ms\r\n    const factory = new Function(pr + \"target\", pr + \"logic\", `\r\n        return function ${target.name}(${repeat(target.length, i => \"v\" + i, \", \")}) {\r\n            ${pr}logic.apply(this, arguments);\r\n            return ${pr}target.apply(this, arguments);\r\n        };\r\n    `);\r\n\r\n    const constructor = factory(target, logic) as Function;\r\n\r\n    // preserve target's prototype and static fields\r\n    constructor.prototype = target.prototype;\r\n    assign(constructor, target);\r\n\r\n    return constructor;\r\n}","﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\r\n/**\r\n * Simple fallback (not polyfill) for ES6 Map\r\n */\r\nexport class MapFallback {\r\n    _store = Object.create(null);\r\n    size = 0;\r\n\r\n    has(key) {\r\n        return this._store[key] !== void 0;\r\n    }\r\n\r\n    get(key) {\r\n        return this._store[key];\r\n    }\r\n\r\n    set(key, value) {\r\n        if (this._store[key] === void 0) {\r\n            this.size++;\r\n        }\r\n        this._store[key] = value;\r\n    }\r\n\r\n    delete(key) {\r\n        if (this._store[key] !== void 0) {\r\n            this.size--;\r\n            delete this._store[key];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Fallback for ES6 Symbol\r\n */\r\nexport function SymbolFallback(key) {\r\n    if (typeof key !== \"string\" && typeof key !== \"number\") {\r\n        throw new Error(\"Symbol not supported\");\r\n    }\r\n    return key;\r\n};","﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport { removeItem, decorateMethod, decorateClass } from \"./utils\";\r\nimport { MapFallback, SymbolFallback } from \"./es5-fallback\";\r\n\r\n// we don't register polyfill - we use local scoped fallback instead\r\nconst _Map: MapConstructor = typeof Map !== \"undefined\" ? Map : MapFallback as any;\r\nconst _Symbol: SymbolConstructor = typeof Symbol !== \"undefined\" ? Symbol : SymbolFallback as any;\r\n\r\ninterface TrieNode {\r\n    handlers: Function[];\r\n    children?: Map<any, TrieNode>;\r\n}\r\n\r\n/**\r\n * Subscription to event at some prefix.\r\n * Used only for unsubscribe from this event by calling `dispose()` method.\r\n * @example\r\n * const subscription = emitter.on(\"event\", (arg: any) => { console.log(arg); });\r\n * subscription.dispose(); // event handler will be removed\r\n */\r\nexport interface Subscription {\r\n    dispose(): void;\r\n}\r\n\r\nclass EmitterSubscription implements Subscription {\r\n    private _node: TrieNode;\r\n    private _args: any[];\r\n    private _handler: Function;\r\n    private _disposed: boolean;\r\n\r\n    constructor(node: TrieNode, args: any[], handler: Function) {\r\n        this._node = node;\r\n        this._args = args;\r\n        this._handler = handler;\r\n        this._disposed = false;\r\n    }\r\n\r\n    dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n        this._disposed = true;\r\n\r\n        if (this._args.length === 0) {\r\n            removeItem(this._node.handlers, this._handler);\r\n            return;\r\n        }\r\n\r\n        let node = this._node;\r\n        const nodeChain = new Array<TrieNode>();\r\n        for (let i = 0; i < this._args.length; ++i) {\r\n            nodeChain.push(node);\r\n            node = node.children.get(this._args[i]);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n        }\r\n        removeItem(node.handlers, this._handler);\r\n        this._cleanupTrie(nodeChain, node);\r\n    }\r\n\r\n    private _cleanupTrie(nodeChain: TrieNode[], node: TrieNode): void {\r\n        for (let i = nodeChain.length - 1; i >= 0; --i) {\r\n            const parent = nodeChain[i];\r\n            if (node.children !== void 0 && node.children.size === 0) {\r\n                node.children = void 0;\r\n            }\r\n            if (node.children === void 0 && node.handlers.length === 0) {\r\n                parent.children.delete(this._args[i]);\r\n            } else {\r\n                return;\r\n            }\r\n            node = parent;\r\n        }\r\n        if (node.children !== void 0 && node.children.size === 0) {\r\n            node.children = void 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Typed emitter without argumens.\r\n * @example\r\n * const emitter: VoidEmitter = new PrefixEmitter();\r\n * const subscription = emitter.on(() => { console.log(\"fired\"); });\r\n */\r\nexport interface VoidEmitter {\r\n    on(handler: () => void): Subscription;\r\n    once(handler: () => void): Subscription;\r\n    emit(): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with one argument.\r\n * @example\r\n * const emitter: SingleEmitter<string> = new PrefixEmitter();\r\n * const sub1 = emitter.on((msg: string) => { console.log(msg); });\r\n * const sub2 = emitter.on(\"some-event\", () => { console.log(\"some-event fired\"); });\r\n */\r\nexport interface SingleEmitter<T> {\r\n    on(handler: (arg: T) => void): Subscription;\r\n    on(arg: T, handler: () => void): Subscription;\r\n    once(handler: (arg: T) => void): Subscription;\r\n    once(arg: T, handler: () => void): Subscription;\r\n    emit(arg: T): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with two arguments.\r\n * @example\r\n * const emitter: DoubleEmitter<string, any> = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"first-event\", (arg: any) => { console.log(\"first-event:\", arg); });\r\n * const sub2 = emitter.on(\"second-event\", (arg: any) => { console.log(\"second-event:\", arg); });\r\n */\r\nexport interface DoubleEmitter<TEvent, TArg> {\r\n    on(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    on(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    on(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    once(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    once(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    once(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    emit(event: TEvent, arg: TArg): void;\r\n}\r\n\r\n/**\r\n * Event Emitter which can bind handlers to events at some sequence of prefixes.\r\n * @example\r\n * const emitter = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"/topic\", \"/event\", (arg: any) => {\r\n *     console.log(\"/topic/event:\", arg);\r\n * });\r\n * const sub2 = emitter.on(\"/topic\", (event: string, arg: any) => {\r\n *     console.log(\"/topic:\", event, arg);\r\n * });\r\n * emitter.emit(\"/event\", \"/subevent\", 123);\r\n * // => \"/topic/event:\", 123\r\n * // => \"/topic:\", \"/event\", 123\r\n * sub1.dispose();\r\n * sub2.dispose();\r\n */\r\nexport class PrefixEmitter implements VoidEmitter, SingleEmitter<any>, DoubleEmitter<any, any> {\r\n    private _node: TrieNode;\r\n\r\n    constructor() {\r\n        this._node = { handlers: new Array<Function>() };\r\n    }\r\n\r\n    private _on(args: any[], handler: Function): Subscription {\r\n        let node = this._node;\r\n        for (let i = 0; i < args.length; ++i) {\r\n            if (node.children === void 0) {\r\n                node.children = new _Map<any, TrieNode>();\r\n            }\r\n            let child = node.children.get(args[i]);\r\n            if (child === void 0) {\r\n                child = { handlers: new Array<Function>() };\r\n                node.children.set(args[i], child);\r\n            }\r\n            node = child;\r\n        }\r\n        node.handlers.push(handler);\r\n        return new EmitterSubscription(this._node, args, handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    on(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        return this._on(args.slice(0, lastIndex), handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter. Subscription will be disposed after single handler call.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    once(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const subscription = this._on(args.slice(0, lastIndex), (...args: any[]) => {\r\n            subscription.dispose();\r\n            handler(...args);\r\n        });\r\n        return subscription;\r\n    }\r\n\r\n    /**\r\n     * Emit one event.\r\n     * @param args Array: event prefixes then event arguments\r\n     */\r\n    emit(...args: any[]): void {\r\n        let node = this._node;\r\n        let handlers = node.handlers;\r\n        let hInd = handlers.length;\r\n        while (hInd--) {\r\n            handlers[hInd].apply(void 0, args);\r\n        }\r\n        let arg: any;\r\n        let aInd = args.length;\r\n        while (node.children !== void 0 && aInd--) {\r\n            arg = args.shift();\r\n            node = node.children.get(arg);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n            handlers = node.handlers;\r\n            hInd = handlers.length;\r\n            while (hInd--) {\r\n                handlers[hInd].apply(void 0, args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface Handler {\r\n    emitter: PrefixEmitter;\r\n    args: any[];\r\n    key: string | symbol;\r\n    once?: boolean;\r\n}\r\n\r\nconst _handlers = _Symbol(\"__prefix_emitter_handlers_\");\r\nconst _subscriptions = _Symbol(\"__prefix_emitter_subscriptions_\");\r\n\r\n// overloads for different interfaces\r\nexport function on(emitter: VoidEmitter): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @on(emitter, \"event\")\r\n *     eventHandler(arg: any) { }\r\n * }\r\n */\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key });\r\n    };\r\n}\r\n\r\n\r\n// overloads for different interfaces\r\nexport function once(emitter: VoidEmitter): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * Subscription will be disposed after single method call.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @once(emitter, \"event\")\r\n *     selfDisposingHandler(arg: any) { }\r\n * }\r\n */\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key, once: true });\r\n    };\r\n}\r\n\r\n/**\r\n * Class Decorator for injecting subscriptions defined by `@on` and `@once` annotations during constructor call.\r\n * @example\r\n * @injectSubscriptions\r\n * class Component {\r\n *     constructor() { }\r\n * }\r\n */\r\nexport function injectSubscriptions<TConstructor extends Function>(target: TConstructor): TConstructor;\r\n\r\n/**\r\n * Method Decorator for injecting subscriptions defined by `@on` and `@once` annotations during method call.\r\n * @example\r\n * class Component {\r\n *     @injectSubscriptions\r\n *     componentDidMount() { }\r\n * }\r\n */\r\nexport function injectSubscriptions(target: Object, key: string | symbol): void;\r\n\r\n/**\r\n * Utility function for injecting subscriptions defined by `@on` and `@once` annotations.\r\n * @example\r\n * class Component {\r\n *     componentDidMount() {\r\n *         injectSubscriptions(this);\r\n *     }\r\n * }\r\n */\r\nexport function injectSubscriptions(target: Object): void;\r\n\r\nexport function injectSubscriptions(\r\n    target: Function | Object, key?: string | symbol,\r\n    descriptor?: TypedPropertyDescriptor<Function>\r\n): TypedPropertyDescriptor<Function> | Function | void {\r\n    if (arguments.length === 3) { // ES5+ method decorator\r\n        descriptor = descriptor || Object.getOwnPropertyDescriptor(target, key);\r\n        descriptor.value = decorateMethod(descriptor.value, logic);\r\n        return descriptor;\r\n    } else if (arguments.length === 2) { // ES3 method decorator\r\n        target[key] = decorateMethod(target[key], logic);\r\n        return;\r\n    } else if (target instanceof Function) { // constructor decorator\r\n        return decorateClass(target, logic);\r\n    } else { // explicit invocation\r\n        logic.call(target);\r\n        return;\r\n    }\r\n\r\n    function logic() {\r\n        const handlers: Handler[] = this[_handlers];\r\n        if (handlers !== void 0 && !this.hasOwnProperty(_subscriptions)) {\r\n            this[_subscriptions] = handlers.map(h => {\r\n                const method: Function = this[h.key].bind(this);\r\n                return h.once\r\n                    ? h.emitter.once(...h.args, method)\r\n                    : h.emitter.on(...h.args, method);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Method Decorator for disposing all injected subscriptions during method call.\r\n * @example\r\n * class Component {\r\n *     @disposeSubscriptions\r\n *     componentWillUnmount() { }\r\n * }\r\n */\r\nexport function disposeSubscriptions(target: Object, key: string | symbol): void;\r\n\r\n/**\r\n * Utility function for disposing all injected subscriptions.\r\n * @example\r\n * class Component {\r\n *     componentWillUnmount() {\r\n *         disposeSubscriptions(this);\r\n *     }\r\n * }\r\n */\r\nexport function disposeSubscriptions(target: Object): void;\r\n\r\nexport function disposeSubscriptions(\r\n    target: Object, key?: string | symbol,\r\n    descriptor?: TypedPropertyDescriptor<Function>\r\n): TypedPropertyDescriptor<Function> | Function | void {\r\n    if (arguments.length === 3) { // ES5+ method decorator\r\n        descriptor = descriptor || Object.getOwnPropertyDescriptor(target, key);\r\n        descriptor.value = decorateMethod(descriptor.value, logic);\r\n        return descriptor;\r\n    } else if (arguments.length === 2) { // ES3 method decorator\r\n        target[key] = decorateMethod(target[key], logic);\r\n    } else { // explicit invocation\r\n        logic.call(target);\r\n    }\r\n\r\n    function logic() {\r\n        const subscriptions: Subscription[] = this[_subscriptions];\r\n        if (subscriptions !== void 0) {\r\n            subscriptions.forEach(s => { s.dispose(); });\r\n            delete this[_subscriptions];\r\n        }\r\n    }\r\n}"],"names":[],"mappings":"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"}
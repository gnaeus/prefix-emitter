{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///prefix-emitter.min.js","webpack:///webpack/bootstrap 727e8978b0adfa018cdb","webpack:///./src/prefix-emitter.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","removeItem","array","item","index","indexOf","splice","shift","on","emitter","args","_i","arguments","length","target","key","descriptor","handlers","_handlers","Array","hasOwnProperty","slice","push","once","injectSubscriptions","_subscriptions","map","h","method","bind","_a","apply","concat","_b","disposeSubscriptions","subscriptions","forEach","s","dispose","EmitterSubscription","node","handler","_node","_args","_handler","_disposed","prototype","nodeChain","children","get","_cleanupTrie","parent_1","size","PrefixEmitter","_on","Map","child","set","lastIndex","Error","subscription","emit","hInd","arg","aInd","Symbol"],"mappings":"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","file":"prefix-emitter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Copyright (c) 2016 Dmitry Panyushkin\r\n\t * Available under MIT license\r\n\t */\r\n\t\"use strict\";\r\n\tvar EmitterSubscription = (function () {\r\n\t    function EmitterSubscription(node, args, handler) {\r\n\t        this._node = node;\r\n\t        this._args = args;\r\n\t        this._handler = handler;\r\n\t        this._disposed = false;\r\n\t    }\r\n\t    EmitterSubscription.prototype.dispose = function () {\r\n\t        if (this._disposed) {\r\n\t            return;\r\n\t        }\r\n\t        this._disposed = true;\r\n\t        if (this._args.length === 0) {\r\n\t            removeItem(this._node.handlers, this._handler);\r\n\t            return;\r\n\t        }\r\n\t        var node = this._node;\r\n\t        var nodeChain = new Array();\r\n\t        for (var i = 0; i < this._args.length; ++i) {\r\n\t            nodeChain.push(node);\r\n\t            node = node.children.get(this._args[i]);\r\n\t            if (node === void 0) {\r\n\t                return;\r\n\t            }\r\n\t        }\r\n\t        removeItem(node.handlers, this._handler);\r\n\t        this._cleanupTrie(nodeChain, node);\r\n\t    };\r\n\t    EmitterSubscription.prototype._cleanupTrie = function (nodeChain, node) {\r\n\t        for (var i = nodeChain.length - 1; i >= 0; --i) {\r\n\t            var parent_1 = nodeChain[i];\r\n\t            if (node.children !== void 0 && node.children.size === 0) {\r\n\t                node.children = void 0;\r\n\t            }\r\n\t            if (node.children === void 0 && node.handlers.length === 0) {\r\n\t                parent_1.children.delete(this._args[i]);\r\n\t            }\r\n\t            else {\r\n\t                return;\r\n\t            }\r\n\t            node = parent_1;\r\n\t        }\r\n\t        if (node.children !== void 0 && node.children.size === 0) {\r\n\t            node.children = void 0;\r\n\t        }\r\n\t    };\r\n\t    return EmitterSubscription;\r\n\t}());\r\n\tfunction removeItem(array, item) {\r\n\t    var index = array.indexOf(item);\r\n\t    if (index > 0) {\r\n\t        array.splice(index, 1);\r\n\t    }\r\n\t    else if (index === 0) {\r\n\t        array.shift();\r\n\t    }\r\n\t}\r\n\tvar PrefixEmitter = (function () {\r\n\t    function PrefixEmitter() {\r\n\t        this._node = { handlers: new Array() };\r\n\t    }\r\n\t    PrefixEmitter.prototype._on = function (args, handler) {\r\n\t        var node = this._node;\r\n\t        for (var i = 0; i < args.length; ++i) {\r\n\t            if (node.children === void 0) {\r\n\t                node.children = new Map();\r\n\t            }\r\n\t            var child = node.children.get(args[i]);\r\n\t            if (child === void 0) {\r\n\t                child = { handlers: new Array() };\r\n\t                node.children.set(args[i], child);\r\n\t            }\r\n\t            node = child;\r\n\t        }\r\n\t        node.handlers.push(handler);\r\n\t        return new EmitterSubscription(this._node, args, handler);\r\n\t    };\r\n\t    PrefixEmitter.prototype.on = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var lastIndex = arguments.length - 1;\r\n\t        if (lastIndex < 0) {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var handler = args[lastIndex];\r\n\t        if (typeof handler !== \"function\") {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        return this._on(args.slice(0, lastIndex), handler);\r\n\t    };\r\n\t    PrefixEmitter.prototype.once = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var lastIndex = arguments.length - 1;\r\n\t        if (lastIndex < 0) {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var handler = args[lastIndex];\r\n\t        if (typeof handler !== \"function\") {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var subscription = this._on(args.slice(0, lastIndex), function () {\r\n\t            var args = [];\r\n\t            for (var _i = 0; _i < arguments.length; _i++) {\r\n\t                args[_i - 0] = arguments[_i];\r\n\t            }\r\n\t            subscription.dispose();\r\n\t            handler.apply(void 0, args);\r\n\t        });\r\n\t        return subscription;\r\n\t    };\r\n\t    PrefixEmitter.prototype.emit = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var node = this._node;\r\n\t        var handlers = node.handlers;\r\n\t        var hInd = handlers.length;\r\n\t        while (hInd--) {\r\n\t            handlers[hInd].apply(void 0, args);\r\n\t        }\r\n\t        var arg;\r\n\t        var aInd = args.length;\r\n\t        while (node.children !== void 0 && aInd--) {\r\n\t            arg = args.shift();\r\n\t            node = node.children.get(arg);\r\n\t            if (node === void 0) {\r\n\t                return;\r\n\t            }\r\n\t            handlers = node.handlers;\r\n\t            hInd = handlers.length;\r\n\t            while (hInd--) {\r\n\t                handlers[hInd].apply(void 0, args);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    return PrefixEmitter;\r\n\t}());\r\n\texports.PrefixEmitter = PrefixEmitter;\r\n\tvar _handlers = Symbol(\"_handlers\");\r\n\tvar _subscriptions = Symbol(\"_subscriptions\");\r\n\tfunction on(emitter) {\r\n\t    var args = [];\r\n\t    for (var _i = 1; _i < arguments.length; _i++) {\r\n\t        args[_i - 1] = arguments[_i];\r\n\t    }\r\n\t    return function (target, key, descriptor) {\r\n\t        var handlers = target[_handlers];\r\n\t        if (handlers === void 0) {\r\n\t            target[_handlers] = handlers = new Array();\r\n\t        }\r\n\t        else if (!target.hasOwnProperty(_handlers)) {\r\n\t            target[_handlers] = handlers = handlers.slice();\r\n\t        }\r\n\t        handlers.push({ emitter: emitter, args: args, key: key });\r\n\t    };\r\n\t}\r\n\texports.on = on;\r\n\tfunction once(emitter) {\r\n\t    var args = [];\r\n\t    for (var _i = 1; _i < arguments.length; _i++) {\r\n\t        args[_i - 1] = arguments[_i];\r\n\t    }\r\n\t    return function (target, key, descriptor) {\r\n\t        var handlers = target[_handlers];\r\n\t        if (handlers === void 0) {\r\n\t            target[_handlers] = handlers = new Array();\r\n\t        }\r\n\t        else if (!target.hasOwnProperty(_handlers)) {\r\n\t            target[_handlers] = handlers = handlers.slice();\r\n\t        }\r\n\t        handlers.push({ emitter: emitter, args: args, key: key, once: true });\r\n\t    };\r\n\t}\r\n\texports.once = once;\r\n\tfunction injectSubscriptions(target) {\r\n\t    var handlers = target[_handlers];\r\n\t    if (handlers !== void 0 && !target.hasOwnProperty(_subscriptions)) {\r\n\t        target[_subscriptions] = handlers.map(function (h) {\r\n\t            var method = target[h.key].bind(target);\r\n\t            return h.once\r\n\t                ? (_a = h.emitter).once.apply(_a, h.args.concat([method]))\r\n\t                : (_b = h.emitter).on.apply(_b, h.args.concat([method]));\r\n\t            var _a, _b;\r\n\t        });\r\n\t    }\r\n\t}\r\n\texports.injectSubscriptions = injectSubscriptions;\r\n\tfunction disposeSubscriptions(target) {\r\n\t    var subscriptions = target[_subscriptions];\r\n\t    if (subscriptions !== void 0) {\r\n\t        subscriptions.forEach(function (s) { s.dispose(); });\r\n\t        delete target[_subscriptions];\r\n\t    }\r\n\t}\r\n\texports.disposeSubscriptions = disposeSubscriptions;\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** prefix-emitter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 727e8978b0adfa018cdb\n **/","/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\r\ninterface TrieNode {\r\n    handlers: Function[],\r\n    children?: Map<any, TrieNode>,\r\n}\r\n\r\nexport interface Subscription {\r\n    dispose(): void,\r\n}\r\n\r\nclass EmitterSubscription implements Subscription {\r\n    private _node: TrieNode;\r\n    private _args: any[];\r\n    private _handler: Function;\r\n    private _disposed: boolean;\r\n\r\n    constructor(node: TrieNode, args: any[], handler: Function) {\r\n        this._node = node;\r\n        this._args = args;\r\n        this._handler = handler;\r\n        this._disposed = false;\r\n    }\r\n\r\n    dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n        this._disposed = true;\r\n\r\n        if (this._args.length === 0) {\r\n            removeItem(this._node.handlers, this._handler);\r\n            return;\r\n        }\r\n        \r\n        let node = this._node;\r\n        const nodeChain = new Array<TrieNode>();\r\n        for (let i = 0; i < this._args.length; ++i) {\r\n            nodeChain.push(node);\r\n            node = node.children.get(this._args[i]);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n        }\r\n        removeItem(node.handlers, this._handler);\r\n        this._cleanupTrie(nodeChain, node);\r\n    }\r\n\r\n    private _cleanupTrie(nodeChain: TrieNode[], node: TrieNode): void {\r\n        for (let i = nodeChain.length - 1; i >= 0; --i) {\r\n            const parent = nodeChain[i];\r\n            if (node.children !== void 0 && node.children.size === 0) {\r\n                node.children = void 0;\r\n            }\r\n            if (node.children === void 0 && node.handlers.length === 0) {\r\n                parent.children.delete(this._args[i]);\r\n            } else {\r\n                return;\r\n            }\r\n            node = parent;\r\n        }\r\n        if (node.children !== void 0 && node.children.size === 0) {\r\n            node.children = void 0;\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeItem(array: any[], item: any): void {\r\n    const index = array.indexOf(item);\r\n    if (index > 0) {\r\n        array.splice(index, 1);\r\n    } else if (index === 0) {\r\n        array.shift();\r\n    }\r\n}\r\n\r\nexport interface VoidEmitter {\r\n    on(handler: () => void): Subscription;\r\n    once(handler: () => void): Subscription;\r\n    emit(): void;\r\n}\r\n\r\nexport interface SingleEmitter<T> {\r\n    on(handler: (arg: T) => void): Subscription;\r\n    on(arg: T, handler: () => void): Subscription;\r\n    once(handler: (arg: T) => void): Subscription;\r\n    once(arg: T, handler: () => void): Subscription;\r\n    emit(arg: T): void;\r\n}\r\n\r\nexport interface DoubleEmitter<TEvent, TArg> {\r\n    on(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    on(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    on(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    once(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    once(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    once(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    emit(event: TEvent, arg: TArg): void;\r\n}\r\n\r\nexport class PrefixEmitter implements VoidEmitter, SingleEmitter<any>, DoubleEmitter<any, any> {\r\n    private _node: TrieNode;\r\n\r\n    constructor() {\r\n        this._node = { handlers: new Array<Function>() };\r\n    }\r\n    \r\n    private _on(args: any[], handler: Function): Subscription {\r\n        let node = this._node;\r\n        for (let i = 0; i < args.length; ++i) {\r\n            if (node.children === void 0) {\r\n                node.children = new Map<any, TrieNode>();\r\n            }\r\n            let child = node.children.get(args[i]);\r\n            if (child === void 0) {\r\n                child = { handlers: new Array<Function>() };\r\n                node.children.set(args[i], child);\r\n            }\r\n            node = child;\r\n        }\r\n        node.handlers.push(handler);\r\n        return new EmitterSubscription(this._node, args, handler);\r\n    }\r\n    \r\n    on(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if(lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if(typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        return this._on(args.slice(0, lastIndex), handler);\r\n    }\r\n    \r\n    once(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const subscription = this._on(args.slice(0, lastIndex), (...args: any[]) => {\r\n            subscription.dispose();\r\n            handler(...args);\r\n        });\r\n        return subscription;\r\n    }\r\n    \r\n    emit(...args: any[]): void {\r\n        let node = this._node;\r\n        let handlers = node.handlers;\r\n        let hInd = handlers.length;\r\n        while (hInd--) {\r\n            handlers[hInd].apply(void 0, args);\r\n        }\r\n        let arg: any;\r\n        let aInd = args.length;\r\n        while (node.children !== void 0 && aInd--) {\r\n            arg = args.shift();\r\n            node = node.children.get(arg);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n            handlers = node.handlers;\r\n            hInd = handlers.length;\r\n            while (hInd--) {\r\n                handlers[hInd].apply(void 0, args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface Handler {\r\n    emitter: PrefixEmitter,\r\n    args: any[],\r\n    key: string | symbol,\r\n    once?: boolean,\r\n}\r\n\r\nconst _handlers = Symbol(\"_handlers\");\r\nconst _subscriptions = Symbol(\"_subscriptions\");\r\n\r\nexport function on(emitter: VoidEmitter): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol, descriptor: PropertyDescriptor) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key });\r\n    }\r\n}\r\n\r\nexport function once(emitter: VoidEmitter): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol, descriptor: PropertyDescriptor) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key, once: true });\r\n    }\r\n}\r\n\r\nexport function injectSubscriptions(target: Object): void {\r\n    const handlers: Handler[] = target[_handlers];\r\n    if (handlers !== void 0 && !target.hasOwnProperty(_subscriptions)) {\r\n        target[_subscriptions] = handlers.map(h => {\r\n            const method: Function = target[h.key].bind(target);\r\n            return h.once\r\n                ? h.emitter.once(...h.args, method)\r\n                : h.emitter.on(...h.args, method);\r\n        });\r\n    }\r\n}\r\n\r\nexport function disposeSubscriptions(target: Object): void {\r\n    const subscriptions: Subscription[] = target[_subscriptions];\r\n    if (subscriptions !== void 0) {\r\n        subscriptions.forEach(s => { s.dispose(); });\r\n        delete target[_subscriptions];\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/prefix-emitter.ts\n **/"],"sourceRoot":""}
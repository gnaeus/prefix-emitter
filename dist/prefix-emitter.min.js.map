{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///prefix-emitter.min.js","webpack:///webpack/bootstrap d370a304bc4cdaef4dda","webpack:///./src/prefix-emitter.ts","webpack:///./src/utils.ts","webpack:///./src/es5-fallback.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","on","emitter","args","_i","arguments","length","target","key","handlers","_handlers","Array","hasOwnProperty","slice","push","once","injectSubscriptions","logic","_this","_subscriptions","map","h","method","bind","_a","apply","concat","_b","Function","utils_ts_1","extendConstructor","extendFunction","Error","disposeSubscriptions","subscriptions","forEach","s","dispose","fallback","_Map","Map","_Symbol","Symbol","EmitterSubscription","node","handler","_node","_args","_handler","_disposed","prototype","removeItem","nodeChain","children","get","_cleanupTrie","parent_1","size","PrefixEmitter","_on","child","set","lastIndex","subscription","emit","hInd","arg","aInd","shift","array","item","index","indexOf","splice","repeat","count","template","sep","arr","join","pr","name","constructor","MapFallback","_store","Object","create","SymbolFallback","has","value"],"mappings":"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","file":"prefix-emitter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * Copyright (c) 2016 Dmitry Panyushkin\r\n\t * Available under MIT license\r\n\t */\r\n\tvar utils_ts_1 = __webpack_require__(1);\r\n\tvar fallback = __webpack_require__(2);\r\n\t// we don't register polyfill - we use local scoped fallback instead\r\n\tvar _Map = typeof Map !== \"undefined\" ? Map : fallback.Map;\r\n\tvar _Symbol = typeof Symbol !== \"undefined\" ? Symbol : fallback.Symbol;\r\n\tvar EmitterSubscription = (function () {\r\n\t    function EmitterSubscription(node, args, handler) {\r\n\t        this._node = node;\r\n\t        this._args = args;\r\n\t        this._handler = handler;\r\n\t        this._disposed = false;\r\n\t    }\r\n\t    EmitterSubscription.prototype.dispose = function () {\r\n\t        if (this._disposed) {\r\n\t            return;\r\n\t        }\r\n\t        this._disposed = true;\r\n\t        if (this._args.length === 0) {\r\n\t            utils_ts_1.removeItem(this._node.handlers, this._handler);\r\n\t            return;\r\n\t        }\r\n\t        var node = this._node;\r\n\t        var nodeChain = new Array();\r\n\t        for (var i = 0; i < this._args.length; ++i) {\r\n\t            nodeChain.push(node);\r\n\t            node = node.children.get(this._args[i]);\r\n\t            if (node === void 0) {\r\n\t                return;\r\n\t            }\r\n\t        }\r\n\t        utils_ts_1.removeItem(node.handlers, this._handler);\r\n\t        this._cleanupTrie(nodeChain, node);\r\n\t    };\r\n\t    EmitterSubscription.prototype._cleanupTrie = function (nodeChain, node) {\r\n\t        for (var i = nodeChain.length - 1; i >= 0; --i) {\r\n\t            var parent_1 = nodeChain[i];\r\n\t            if (node.children !== void 0 && node.children.size === 0) {\r\n\t                node.children = void 0;\r\n\t            }\r\n\t            if (node.children === void 0 && node.handlers.length === 0) {\r\n\t                parent_1.children.delete(this._args[i]);\r\n\t            }\r\n\t            else {\r\n\t                return;\r\n\t            }\r\n\t            node = parent_1;\r\n\t        }\r\n\t        if (node.children !== void 0 && node.children.size === 0) {\r\n\t            node.children = void 0;\r\n\t        }\r\n\t    };\r\n\t    return EmitterSubscription;\r\n\t}());\r\n\t/**\r\n\t * Event Emitter which can bind handlers to events at some sequence of prefixes.\r\n\t * @example\r\n\t * const emitter = new PrefixEmitter();\r\n\t * const sub1 = emitter.on(\"/topic\", \"/event\", (arg: any) => {\r\n\t *     console.log(\"/topic/event:\", arg);\r\n\t * });\r\n\t * const sub2 = emitter.on(\"/topic\", (event: string, arg: any) => {\r\n\t *     console.log(\"/topic:\", event, arg);\r\n\t * });\r\n\t * emitter.emit(\"/event\", \"/subevent\", 123);\r\n\t * // => \"/topic/event:\", 123\r\n\t * // => \"/topic:\", \"/event\", 123\r\n\t * sub1.dispose();\r\n\t * sub2.dispose();\r\n\t */\r\n\tvar PrefixEmitter = (function () {\r\n\t    function PrefixEmitter() {\r\n\t        this._node = { handlers: new Array() };\r\n\t    }\r\n\t    PrefixEmitter.prototype._on = function (args, handler) {\r\n\t        var node = this._node;\r\n\t        for (var i = 0; i < args.length; ++i) {\r\n\t            if (node.children === void 0) {\r\n\t                node.children = new _Map();\r\n\t            }\r\n\t            var child = node.children.get(args[i]);\r\n\t            if (child === void 0) {\r\n\t                child = { handlers: new Array() };\r\n\t                node.children.set(args[i], child);\r\n\t            }\r\n\t            node = child;\r\n\t        }\r\n\t        node.handlers.push(handler);\r\n\t        return new EmitterSubscription(this._node, args, handler);\r\n\t    };\r\n\t    /**\r\n\t     * Subscribe to some event from this Emitter.\r\n\t     * @param args Array: sequence of event prefixes and event handler function at last position\r\n\t     * @returns Subscription: created subscription to event\r\n\t     */\r\n\t    PrefixEmitter.prototype.on = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var lastIndex = arguments.length - 1;\r\n\t        if (lastIndex < 0) {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var handler = args[lastIndex];\r\n\t        if (typeof handler !== \"function\") {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        return this._on(args.slice(0, lastIndex), handler);\r\n\t    };\r\n\t    /**\r\n\t     * Subscribe to some event from this Emitter. Subscription will be disposed after single handler call.\r\n\t     * @param args Array: sequence of event prefixes and event handler function at last position\r\n\t     * @returns Subscription: created subscription to event\r\n\t     */\r\n\t    PrefixEmitter.prototype.once = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var lastIndex = arguments.length - 1;\r\n\t        if (lastIndex < 0) {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var handler = args[lastIndex];\r\n\t        if (typeof handler !== \"function\") {\r\n\t            throw new Error(\"last argument is not a function\");\r\n\t        }\r\n\t        var subscription = this._on(args.slice(0, lastIndex), function () {\r\n\t            var args = [];\r\n\t            for (var _i = 0; _i < arguments.length; _i++) {\r\n\t                args[_i - 0] = arguments[_i];\r\n\t            }\r\n\t            subscription.dispose();\r\n\t            handler.apply(void 0, args);\r\n\t        });\r\n\t        return subscription;\r\n\t    };\r\n\t    /**\r\n\t     * Emit one event.\r\n\t     * @param args Array: event prefixes then event arguments\r\n\t     */\r\n\t    PrefixEmitter.prototype.emit = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var node = this._node;\r\n\t        var handlers = node.handlers;\r\n\t        var hInd = handlers.length;\r\n\t        while (hInd--) {\r\n\t            handlers[hInd].apply(void 0, args);\r\n\t        }\r\n\t        var arg;\r\n\t        var aInd = args.length;\r\n\t        while (node.children !== void 0 && aInd--) {\r\n\t            arg = args.shift();\r\n\t            node = node.children.get(arg);\r\n\t            if (node === void 0) {\r\n\t                return;\r\n\t            }\r\n\t            handlers = node.handlers;\r\n\t            hInd = handlers.length;\r\n\t            while (hInd--) {\r\n\t                handlers[hInd].apply(void 0, args);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    return PrefixEmitter;\r\n\t}());\r\n\texports.PrefixEmitter = PrefixEmitter;\r\n\tvar _handlers = _Symbol(\"__prefix_emitter_handlers_\");\r\n\tvar _subscriptions = _Symbol(\"__prefix_emitter_subscriptions_\");\r\n\t/**\r\n\t * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n\t * @param emitter PrefixEmitter: some emitter\r\n\t * @param args Array: sequence of event prefixes\r\n\t * @example\r\n\t * class Component {\r\n\t *     @on(emitter, \"event\")\r\n\t *     eventHandler(arg: any) { }\r\n\t * }\r\n\t */\r\n\tfunction on(emitter) {\r\n\t    var args = [];\r\n\t    for (var _i = 1; _i < arguments.length; _i++) {\r\n\t        args[_i - 1] = arguments[_i];\r\n\t    }\r\n\t    return function (target, key) {\r\n\t        var handlers = target[_handlers];\r\n\t        if (handlers === void 0) {\r\n\t            target[_handlers] = handlers = new Array();\r\n\t        }\r\n\t        else if (!target.hasOwnProperty(_handlers)) {\r\n\t            target[_handlers] = handlers = handlers.slice();\r\n\t        }\r\n\t        handlers.push({ emitter: emitter, args: args, key: key });\r\n\t    };\r\n\t}\r\n\texports.on = on;\r\n\t/**\r\n\t * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n\t * Subscription will be disposed after single method call.\r\n\t * @param emitter PrefixEmitter: some emitter\r\n\t * @param args Array: sequence of event prefixes\r\n\t * @example\r\n\t * class Component {\r\n\t *     @once(emitter, \"event\")\r\n\t *     selfDisposingHandler(arg: any) { }\r\n\t * }\r\n\t */\r\n\tfunction once(emitter) {\r\n\t    var args = [];\r\n\t    for (var _i = 1; _i < arguments.length; _i++) {\r\n\t        args[_i - 1] = arguments[_i];\r\n\t    }\r\n\t    return function (target, key) {\r\n\t        var handlers = target[_handlers];\r\n\t        if (handlers === void 0) {\r\n\t            target[_handlers] = handlers = new Array();\r\n\t        }\r\n\t        else if (!target.hasOwnProperty(_handlers)) {\r\n\t            target[_handlers] = handlers = handlers.slice();\r\n\t        }\r\n\t        handlers.push({ emitter: emitter, args: args, key: key, once: true });\r\n\t    };\r\n\t}\r\n\texports.once = once;\r\n\tfunction injectSubscriptions(target, key) {\r\n\t    if (target instanceof Function) {\r\n\t        return utils_ts_1.extendConstructor(target, logic);\r\n\t    }\r\n\t    else if (key !== void 0) {\r\n\t        target[key] = utils_ts_1.extendFunction(target[key], logic);\r\n\t        return void 0;\r\n\t    }\r\n\t    else {\r\n\t        throw new Error(\"Decorator should be used on class or method\");\r\n\t    }\r\n\t    function logic() {\r\n\t        var _this = this;\r\n\t        var handlers = this[_handlers];\r\n\t        if (handlers !== void 0 && !this.hasOwnProperty(_subscriptions)) {\r\n\t            this[_subscriptions] = handlers.map(function (h) {\r\n\t                var method = _this[h.key].bind(_this);\r\n\t                return h.once\r\n\t                    ? (_a = h.emitter).once.apply(_a, h.args.concat([method]))\r\n\t                    : (_b = h.emitter).on.apply(_b, h.args.concat([method]));\r\n\t                var _a, _b;\r\n\t            });\r\n\t        }\r\n\t    }\r\n\t}\r\n\texports.injectSubscriptions = injectSubscriptions;\r\n\t/**\r\n\t * Method Decorator for disposing all injected subscriptions during method call.\r\n\t * @example\r\n\t * class Component {\r\n\t *     @disposeSubscriptions\r\n\t *     componentWillUnmount() { }\r\n\t * }\r\n\t */\r\n\tfunction disposeSubscriptions(target, key) {\r\n\t    target[key] = utils_ts_1.extendFunction(target[key], function logic() {\r\n\t        var subscriptions = this[_subscriptions];\r\n\t        if (subscriptions !== void 0) {\r\n\t            subscriptions.forEach(function (s) { s.dispose(); });\r\n\t            delete this[_subscriptions];\r\n\t        }\r\n\t    });\r\n\t}\r\n\texports.disposeSubscriptions = disposeSubscriptions;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * Remove first occurrence of given item from the array.\r\n\t * @param array Array\r\n\t * @param item any\r\n\t */\r\n\tfunction removeItem(array, item) {\r\n\t    var index = array.indexOf(item);\r\n\t    if (index > 0) {\r\n\t        array.splice(index, 1);\r\n\t    }\r\n\t    else if (index === 0) {\r\n\t        array.shift();\r\n\t    }\r\n\t}\r\n\texports.removeItem = removeItem;\r\n\tfunction repeat(count, template, sep) {\r\n\t    if (sep === void 0) { sep = \"\"; }\r\n\t    var arr = [];\r\n\t    for (var i = 0; i < count; ++i) {\r\n\t        arr.push(template(i));\r\n\t    }\r\n\t    return arr.join(sep);\r\n\t}\r\n\t/**\r\n\t * Build new function from given one with injected logic at the beginning of function call.\r\n\t * @param target Function: target function\r\n\t * @param logic Function: injected logic\r\n\t * @returns Function\r\n\t */\r\n\tfunction extendFunction(target, logic) {\r\n\t    // unique prefix for Function constructor for\r\n\t    // eliminate conflicts with `target` functions names\r\n\t    var pr = \"bvjxRy0LjL9D\";\r\n\t    // Code generation is used to preserve target's `.name` and `.length`\r\n\t    // It is about 30x slower than simple funciton wrapping\r\n\t    // But it is slill less than 5 microseconds per call\r\n\t    // So if you have 200 decorated classes it took less then 1ms\r\n\t    var factory = new Function(pr + \"target\", pr + \"logic\", \"\\n        return function \" + target.name + \"(\" + repeat(target.length, function (i) { return \"v\" + i; }, \", \") + \") {\\n            \" + pr + \"logic.apply(this, arguments);\\n            return \" + pr + \"target.apply(this, arguments);\\n        };\\n    \");\r\n\t    return factory(target, logic);\r\n\t}\r\n\texports.extendFunction = extendFunction;\r\n\t/**\r\n\t * Build new constructor from given one with injected logic at the beginning of constructor call.\r\n\t * @param target Function: target constructor\r\n\t * @param logic Function: injected logic\r\n\t * @returns Function\r\n\t */\r\n\tfunction extendConstructor(target, logic) {\r\n\t    var constructor = extendFunction(target, logic);\r\n\t    constructor.prototype = target.prototype;\r\n\t    return constructor;\r\n\t}\r\n\texports.extendConstructor = extendConstructor;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Copyright (c) 2016 Dmitry Panyushkin\r\n\t * Available under MIT license\r\n\t */\r\n\t\"use strict\";\r\n\t\r\n\t/**\r\n\t * Simple fallback (not polyfill) for ES6 Map\r\n\t */\r\n\tfunction MapFallback() {\r\n\t    this._store = Object.create(null);\r\n\t    this.size = 0;\r\n\t}\r\n\t\r\n\tMapFallback.prototype.has = function (key) {\r\n\t    return this._store[key] !== void 0;\r\n\t}\r\n\t\r\n\tMapFallback.prototype.get = function (key) {\r\n\t    return this._store[key];\r\n\t}\r\n\t\r\n\tMapFallback.prototype.set = function (key, value) {\r\n\t    if (this._store[key] === void 0) {\r\n\t        this.size++;\r\n\t    }\r\n\t    this._store[key] = value;\r\n\t}\r\n\t\r\n\tMapFallback.prototype.delete = function (key) {\r\n\t    if (this._store[key] !== void 0) {\r\n\t        this.size--;\r\n\t        delete this._store[key];\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * Fallback for ES6 Symbol\r\n\t */\r\n\tfunction SymbolFallback(key) {\r\n\t    if (typeof key !== \"string\" && typeof key !== \"number\") {\r\n\t        throw new Error(\"Symbol not supported\");\r\n\t    }\r\n\t    return key;\r\n\t}\r\n\t\r\n\tmodule.exports = {\r\n\t    Map: MapFallback,\r\n\t    Symbol: SymbolFallback,\r\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** prefix-emitter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d370a304bc4cdaef4dda\n **/","/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport { removeItem, extendFunction, extendConstructor } from \"./utils.ts\";\r\n\r\n// call `require()` from webpack\r\ndeclare function require(path: string): any;\r\nconst fallback = require(\"./es5-fallback.js\");\r\n\r\n// we don't register polyfill - we use local scoped fallback instead\r\nconst _Map: MapConstructor = typeof Map !== \"undefined\" ? Map : fallback.Map;\r\nconst _Symbol: SymbolConstructor = typeof Symbol !== \"undefined\" ? Symbol : fallback.Symbol;\r\n\r\ninterface TrieNode {\r\n    handlers: Function[],\r\n    children?: Map<any, TrieNode>,\r\n}\r\n\r\n/**\r\n * Subscription to event at some prefix.\r\n * Used only for unsubscribe from this event by calling `dispose()` method.\r\n * @example\r\n * const subscription = emitter.on(\"event\", (arg: any) => { console.log(arg); });\r\n * subscription.dispose(); // event handler will be removed\r\n */\r\nexport interface Subscription {\r\n    dispose(): void,\r\n}\r\n\r\nclass EmitterSubscription implements Subscription {\r\n    private _node: TrieNode;\r\n    private _args: any[];\r\n    private _handler: Function;\r\n    private _disposed: boolean;\r\n\r\n    constructor(node: TrieNode, args: any[], handler: Function) {\r\n        this._node = node;\r\n        this._args = args;\r\n        this._handler = handler;\r\n        this._disposed = false;\r\n    }\r\n\r\n    dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n        this._disposed = true;\r\n\r\n        if (this._args.length === 0) {\r\n            removeItem(this._node.handlers, this._handler);\r\n            return;\r\n        }\r\n        \r\n        let node = this._node;\r\n        const nodeChain = new Array<TrieNode>();\r\n        for (let i = 0; i < this._args.length; ++i) {\r\n            nodeChain.push(node);\r\n            node = node.children.get(this._args[i]);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n        }\r\n        removeItem(node.handlers, this._handler);\r\n        this._cleanupTrie(nodeChain, node);\r\n    }\r\n\r\n    private _cleanupTrie(nodeChain: TrieNode[], node: TrieNode): void {\r\n        for (let i = nodeChain.length - 1; i >= 0; --i) {\r\n            const parent = nodeChain[i];\r\n            if (node.children !== void 0 && node.children.size === 0) {\r\n                node.children = void 0;\r\n            }\r\n            if (node.children === void 0 && node.handlers.length === 0) {\r\n                parent.children.delete(this._args[i]);\r\n            } else {\r\n                return;\r\n            }\r\n            node = parent;\r\n        }\r\n        if (node.children !== void 0 && node.children.size === 0) {\r\n            node.children = void 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Typed emitter without argumens.\r\n * @example\r\n * const emitter: VoidEmitter = new PrefixEmitter();\r\n * const subscription = emitter.on(() => { console.log(\"fired\"); });\r\n */\r\nexport interface VoidEmitter {\r\n    on(handler: () => void): Subscription;\r\n    once(handler: () => void): Subscription;\r\n    emit(): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with one argument.\r\n * @example\r\n * const emitter: SingleEmitter<string> = new PrefixEmitter();\r\n * const sub1 = emitter.on((msg: string) => { console.log(msg); });\r\n * const sub2 = emitter.on(\"some-event\", () => { console.log(\"some-event fired\"); });\r\n */\r\nexport interface SingleEmitter<T> {\r\n    on(handler: (arg: T) => void): Subscription;\r\n    on(arg: T, handler: () => void): Subscription;\r\n    once(handler: (arg: T) => void): Subscription;\r\n    once(arg: T, handler: () => void): Subscription;\r\n    emit(arg: T): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with two arguments.\r\n * @example\r\n * const emitter: DoubleEmitter<string, any> = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"first-event\", (arg: any) => { console.log(\"first-event:\", arg); });\r\n * const sub2 = emitter.on(\"second-event\", (arg: any) => { console.log(\"second-event:\", arg); });\r\n */\r\nexport interface DoubleEmitter<TEvent, TArg> {\r\n    on(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    on(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    on(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    once(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    once(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    once(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    emit(event: TEvent, arg: TArg): void;\r\n}\r\n\r\n/**\r\n * Event Emitter which can bind handlers to events at some sequence of prefixes.\r\n * @example\r\n * const emitter = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"/topic\", \"/event\", (arg: any) => {\r\n *     console.log(\"/topic/event:\", arg);\r\n * });\r\n * const sub2 = emitter.on(\"/topic\", (event: string, arg: any) => {\r\n *     console.log(\"/topic:\", event, arg);\r\n * });\r\n * emitter.emit(\"/event\", \"/subevent\", 123);\r\n * // => \"/topic/event:\", 123\r\n * // => \"/topic:\", \"/event\", 123\r\n * sub1.dispose();\r\n * sub2.dispose();\r\n */\r\nexport class PrefixEmitter implements VoidEmitter, SingleEmitter<any>, DoubleEmitter<any, any> {\r\n    private _node: TrieNode;\r\n\r\n    constructor() {\r\n        this._node = { handlers: new Array<Function>() };\r\n    }\r\n    \r\n    private _on(args: any[], handler: Function): Subscription {\r\n        let node = this._node;\r\n        for (let i = 0; i < args.length; ++i) {\r\n            if (node.children === void 0) {\r\n                node.children = new _Map<any, TrieNode>();\r\n            }\r\n            let child = node.children.get(args[i]);\r\n            if (child === void 0) {\r\n                child = { handlers: new Array<Function>() };\r\n                node.children.set(args[i], child);\r\n            }\r\n            node = child;\r\n        }\r\n        node.handlers.push(handler);\r\n        return new EmitterSubscription(this._node, args, handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    on(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if(lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if(typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        return this._on(args.slice(0, lastIndex), handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter. Subscription will be disposed after single handler call.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    once(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const subscription = this._on(args.slice(0, lastIndex), (...args: any[]) => {\r\n            subscription.dispose();\r\n            handler(...args);\r\n        });\r\n        return subscription;\r\n    }\r\n\r\n    /**\r\n     * Emit one event.\r\n     * @param args Array: event prefixes then event arguments\r\n     */\r\n    emit(...args: any[]): void {\r\n        let node = this._node;\r\n        let handlers = node.handlers;\r\n        let hInd = handlers.length;\r\n        while (hInd--) {\r\n            handlers[hInd].apply(void 0, args);\r\n        }\r\n        let arg: any;\r\n        let aInd = args.length;\r\n        while (node.children !== void 0 && aInd--) {\r\n            arg = args.shift();\r\n            node = node.children.get(arg);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n            handlers = node.handlers;\r\n            hInd = handlers.length;\r\n            while (hInd--) {\r\n                handlers[hInd].apply(void 0, args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface Handler {\r\n    emitter: PrefixEmitter,\r\n    args: any[],\r\n    key: string | symbol,\r\n    once?: boolean,\r\n}\r\n\r\nconst _handlers = _Symbol(\"__prefix_emitter_handlers_\");\r\nconst _subscriptions = _Symbol(\"__prefix_emitter_subscriptions_\");\r\n\r\n// overloads for different interfaces\r\nexport function on(emitter: VoidEmitter): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @on(emitter, \"event\")\r\n *     eventHandler(arg: any) { }\r\n * }\r\n */\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key });\r\n    }\r\n}\r\n\r\n\r\n// overloads for different interfaces\r\nexport function once(emitter: VoidEmitter): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * Subscription will be disposed after single method call.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @once(emitter, \"event\")\r\n *     selfDisposingHandler(arg: any) { }\r\n * }\r\n */\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key, once: true });\r\n    }\r\n}\r\n\r\n/**\r\n * Class Decorator for injecting subscriptions defined by `@on` and `@once` annotations during constructor call.\r\n * @example\r\n * @injectSubscriptions\r\n * class Component {\r\n *     constructor() { }\r\n * }\r\n */\r\nexport function injectSubscriptions<TConstructor extends Function>(target: TConstructor): TConstructor;\r\n\r\n/**\r\n * Method Decorator for injecting subscriptions defined by `@on` and `@once` annotations during method call.\r\n * @example\r\n * class Component {\r\n *     @injectSubscriptions\r\n *     componentDidMount() { }\r\n * }\r\n */\r\nexport function injectSubscriptions(target: Object, key: string | symbol): void;\r\n\r\nexport function injectSubscriptions(target: Function | Object, key?: string | symbol) {\r\n    if (target instanceof Function) {\r\n        return extendConstructor(target, logic);\r\n    } else if (key !== void 0) {\r\n        target[key] = extendFunction(target[key], logic);\r\n        return void 0;\r\n    } else {\r\n        throw new Error(\"Decorator should be used on class or method\");\r\n    }\r\n    \r\n    function logic() {\r\n        const handlers: Handler[] = this[_handlers];\r\n        if (handlers !== void 0 && !this.hasOwnProperty(_subscriptions)) {\r\n            this[_subscriptions] = handlers.map(h => {\r\n                const method: Function = this[h.key].bind(this);\r\n                return h.once\r\n                    ? h.emitter.once(...h.args, method)\r\n                    : h.emitter.on(...h.args, method);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Method Decorator for disposing all injected subscriptions during method call.\r\n * @example\r\n * class Component {\r\n *     @disposeSubscriptions\r\n *     componentWillUnmount() { }\r\n * }\r\n */\r\nexport function disposeSubscriptions(target: Object, key: string | symbol) {\r\n    target[key] = extendFunction(target[key], function logic() {\r\n        const subscriptions: Subscription[] = this[_subscriptions];\r\n        if (subscriptions !== void 0) {\r\n            subscriptions.forEach(s => { s.dispose(); });\r\n            delete this[_subscriptions];\r\n        }\r\n    });\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/prefix-emitter.ts\n **/","/**\r\n * Remove first occurrence of given item from the array.\r\n * @param array Array\r\n * @param item any\r\n */\r\nexport function removeItem(array: any[], item: any): void {\r\n    const index = array.indexOf(item);\r\n    if (index > 0) {\r\n        array.splice(index, 1);\r\n    } else if (index === 0) {\r\n        array.shift();\r\n    }\r\n}\r\n\r\nfunction repeat(count: number, template: (i: number) => string, sep = \"\"): string {\r\n    const arr: any[] = [];\r\n    for (let i = 0; i < count; ++i) {\r\n        arr.push(template(i));\r\n    }\r\n    return arr.join(sep);\r\n}\r\n\r\n/**\r\n * Build new function from given one with injected logic at the beginning of function call.\r\n * @param target Function: target function\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport function extendFunction(target: Function, logic: Function): Function {\r\n    // unique prefix for Function constructor for\r\n    // eliminate conflicts with `target` functions names\r\n    const pr = \"bvjxRy0LjL9D\";\r\n\r\n    // Code generation is used to preserve target's `.name` and `.length`\r\n    // It is about 30x slower than simple funciton wrapping\r\n    // But it is slill less than 5 microseconds per call\r\n    // So if you have 200 decorated classes it took less then 1ms\r\n    const factory = new Function(pr + \"target\", pr + \"logic\", `\r\n        return function ${target.name}(${repeat(target.length, i => \"v\" + i, \", \")}) {\r\n            ${pr}logic.apply(this, arguments);\r\n            return ${pr}target.apply(this, arguments);\r\n        };\r\n    `);\r\n    return factory(target, logic);\r\n}\r\n\r\n/**\r\n * Build new constructor from given one with injected logic at the beginning of constructor call.\r\n * @param target Function: target constructor\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport function extendConstructor(target: Function, logic: Function): Function {\r\n    const constructor = extendFunction(target, logic);\r\n    constructor.prototype = target.prototype;\r\n    return constructor as any;\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.ts\n **/","/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * Simple fallback (not polyfill) for ES6 Map\r\n */\r\nfunction MapFallback() {\r\n    this._store = Object.create(null);\r\n    this.size = 0;\r\n}\r\n\r\nMapFallback.prototype.has = function (key) {\r\n    return this._store[key] !== void 0;\r\n}\r\n\r\nMapFallback.prototype.get = function (key) {\r\n    return this._store[key];\r\n}\r\n\r\nMapFallback.prototype.set = function (key, value) {\r\n    if (this._store[key] === void 0) {\r\n        this.size++;\r\n    }\r\n    this._store[key] = value;\r\n}\r\n\r\nMapFallback.prototype.delete = function (key) {\r\n    if (this._store[key] !== void 0) {\r\n        this.size--;\r\n        delete this._store[key];\r\n    }\r\n}\r\n\r\n/**\r\n * Fallback for ES6 Symbol\r\n */\r\nfunction SymbolFallback(key) {\r\n    if (typeof key !== \"string\" && typeof key !== \"number\") {\r\n        throw new Error(\"Symbol not supported\");\r\n    }\r\n    return key;\r\n}\r\n\r\nmodule.exports = {\r\n    Map: MapFallback,\r\n    Symbol: SymbolFallback,\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/es5-fallback.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}
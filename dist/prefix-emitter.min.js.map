{"version":3,"file":null,"sources":["../src/utils.ts","../src/es5-fallback.ts","../src/prefix-emitter.ts"],"sourcesContent":["﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\r\n/**\r\n * Remove first occurrence of given item from the array.\r\n * @param array Array\r\n * @param item any\r\n */\r\nexport function removeItem(array: any[], item: any): void {\r\n    const index = array.indexOf(item);\r\n    if (index > 0) {\r\n        array.splice(index, 1);\r\n    } else if (index === 0) {\r\n        array.shift();\r\n    }\r\n}\r\n\r\nfunction repeat(count: number, template: (i: number) => string, sep = \"\"): string {\r\n    const arr: any[] = [];\r\n    for (let i = 1; i <= count; ++i) {\r\n        arr.push(template(i));\r\n    }\r\n    return arr.join(sep);\r\n}\r\n\r\nfunction assign(target: Object, source: Object): void {\r\n    for (let k in source) {\r\n        if (source.hasOwnProperty(k)) {\r\n            target[k] = source[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Build new function from given one with injected logic at the beginning of function call.\r\n * @param target Function: target function\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport const decorateMethod: (target: Function, logic: Function) => Function = new Function(\"target\", \"logic\", `\r\n    switch (target.length) {${repeat(16, l => `\r\n        ${l < 16 ? `case ${l}` : `default`}: return function (${repeat(l, i => \"v\" + i, \", \")}) {\r\n            logic.apply(this, arguments);\r\n            return target.apply(this, arguments);\r\n        };`)}\r\n    }\r\n`) as any;\r\n\r\n/**\r\n * Build new constructor from given one with injected logic at the beginning of constructor call.\r\n * @param target Function: target constructor\r\n * @param logic Function: injected logic\r\n * @returns Function\r\n */\r\nexport function decorateClass(target: Function, logic: Function): Function {\r\n    // unique prefix for Function constructor for\r\n    // eliminate conflicts with `target` functions names\r\n    const pr = \"bvjxRy0LjL9D\";\r\n\r\n    // Code generation is used to preserve target's `.name` and `.length`\r\n    // It is about 30x slower than simple funciton wrapping\r\n    // But it is slill less than 5 microseconds per call\r\n    // So if you have 200 decorated classes it took less then 1ms\r\n    const factory = new Function(pr + \"target\", pr + \"logic\", `\r\n        return function ${target.name}(${repeat(target.length, i => \"v\" + i, \", \")}) {\r\n            ${pr}logic.apply(this, arguments);\r\n            return ${pr}target.apply(this, arguments);\r\n        };\r\n    `);\r\n\r\n    const constructor = factory(target, logic) as Function;\r\n\r\n    // preserve target's prototype and static fields\r\n    constructor.prototype = target.prototype;\r\n    assign(constructor, target);\r\n\r\n    return constructor;\r\n}","﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\n\r\n/**\r\n * Simple fallback (not polyfill) for ES6 Map\r\n */\r\nexport class MapFallback {\r\n    _store = Object.create(null);\r\n    size = 0;\r\n\r\n    has(key) {\r\n        return this._store[key] !== void 0;\r\n    }\r\n\r\n    get(key) {\r\n        return this._store[key];\r\n    }\r\n\r\n    set(key, value) {\r\n        if (this._store[key] === void 0) {\r\n            this.size++;\r\n        }\r\n        this._store[key] = value;\r\n    }\r\n\r\n    delete(key) {\r\n        if (this._store[key] !== void 0) {\r\n            this.size--;\r\n            delete this._store[key];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Fallback for ES6 Symbol\r\n */\r\nexport function SymbolFallback(key) {\r\n    if (typeof key !== \"string\" && typeof key !== \"number\") {\r\n        throw new Error(\"Symbol not supported\");\r\n    }\r\n    return key;\r\n};","﻿/**\r\n * Copyright (c) 2016 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport { removeItem, decorateMethod, decorateClass } from \"./utils\";\r\nimport { MapFallback, SymbolFallback } from \"./es5-fallback\";\r\n\r\n// we don't register polyfill - we use local scoped fallback instead\r\nconst _Map: MapConstructor = typeof Map !== \"undefined\" ? Map : MapFallback as any;\r\nconst _Symbol: SymbolConstructor = typeof Symbol !== \"undefined\" ? Symbol : SymbolFallback as any;\r\n\r\ninterface TrieNode {\r\n    handlers: Function[];\r\n    children?: Map<any, TrieNode>;\r\n}\r\n\r\n/**\r\n * Subscription to event at some prefix.\r\n * Used only for unsubscribe from this event by calling `dispose()` method.\r\n * @example\r\n * const subscription = emitter.on(\"event\", (arg: any) => { console.log(arg); });\r\n * subscription.dispose(); // event handler will be removed\r\n */\r\nexport interface Subscription {\r\n    dispose(): void;\r\n}\r\n\r\nclass EmitterSubscription implements Subscription {\r\n    private _node: TrieNode;\r\n    private _args: any[];\r\n    private _handler: Function;\r\n    private _disposed: boolean;\r\n\r\n    constructor(node: TrieNode, args: any[], handler: Function) {\r\n        this._node = node;\r\n        this._args = args;\r\n        this._handler = handler;\r\n        this._disposed = false;\r\n    }\r\n\r\n    dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n        this._disposed = true;\r\n\r\n        if (this._args.length === 0) {\r\n            removeItem(this._node.handlers, this._handler);\r\n            return;\r\n        }\r\n\r\n        let node = this._node;\r\n        const nodeChain = new Array<TrieNode>();\r\n        for (let i = 0; i < this._args.length; ++i) {\r\n            nodeChain.push(node);\r\n            node = node.children.get(this._args[i]);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n        }\r\n        removeItem(node.handlers, this._handler);\r\n        this._cleanupTrie(nodeChain, node);\r\n    }\r\n\r\n    private _cleanupTrie(nodeChain: TrieNode[], node: TrieNode): void {\r\n        for (let i = nodeChain.length - 1; i >= 0; --i) {\r\n            const parent = nodeChain[i];\r\n            if (node.children !== void 0 && node.children.size === 0) {\r\n                node.children = void 0;\r\n            }\r\n            if (node.children === void 0 && node.handlers.length === 0) {\r\n                parent.children.delete(this._args[i]);\r\n            } else {\r\n                return;\r\n            }\r\n            node = parent;\r\n        }\r\n        if (node.children !== void 0 && node.children.size === 0) {\r\n            node.children = void 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Typed emitter without argumens.\r\n * @example\r\n * const emitter: VoidEmitter = new PrefixEmitter();\r\n * const subscription = emitter.on(() => { console.log(\"fired\"); });\r\n */\r\nexport interface VoidEmitter {\r\n    on(handler: () => void): Subscription;\r\n    once(handler: () => void): Subscription;\r\n    emit(): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with one argument.\r\n * @example\r\n * const emitter: SingleEmitter<string> = new PrefixEmitter();\r\n * const sub1 = emitter.on((msg: string) => { console.log(msg); });\r\n * const sub2 = emitter.on(\"some-event\", () => { console.log(\"some-event fired\"); });\r\n */\r\nexport interface SingleEmitter<T> {\r\n    on(handler: (arg: T) => void): Subscription;\r\n    on(arg: T, handler: () => void): Subscription;\r\n    once(handler: (arg: T) => void): Subscription;\r\n    once(arg: T, handler: () => void): Subscription;\r\n    emit(arg: T): void;\r\n}\r\n\r\n/**\r\n * Typed emitter with two arguments.\r\n * @example\r\n * const emitter: DoubleEmitter<string, any> = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"first-event\", (arg: any) => { console.log(\"first-event:\", arg); });\r\n * const sub2 = emitter.on(\"second-event\", (arg: any) => { console.log(\"second-event:\", arg); });\r\n */\r\nexport interface DoubleEmitter<TEvent, TArg> {\r\n    on(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    on(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    on(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    once(handler: (event: TEvent, arg: TArg) => void): Subscription;\r\n    once(event: TEvent, handler: (arg: TArg) => void): Subscription;\r\n    once(event: TEvent, arg: TArg, handler: () => void): Subscription;\r\n    emit(event: TEvent, arg: TArg): void;\r\n}\r\n\r\n/**\r\n * Event Emitter which can bind handlers to events at some sequence of prefixes.\r\n * @example\r\n * const emitter = new PrefixEmitter();\r\n * const sub1 = emitter.on(\"/topic\", \"/event\", (arg: any) => {\r\n *     console.log(\"/topic/event:\", arg);\r\n * });\r\n * const sub2 = emitter.on(\"/topic\", (event: string, arg: any) => {\r\n *     console.log(\"/topic:\", event, arg);\r\n * });\r\n * emitter.emit(\"/event\", \"/subevent\", 123);\r\n * // => \"/topic/event:\", 123\r\n * // => \"/topic:\", \"/event\", 123\r\n * sub1.dispose();\r\n * sub2.dispose();\r\n */\r\nexport class PrefixEmitter implements VoidEmitter, SingleEmitter<any>, DoubleEmitter<any, any> {\r\n    private _node: TrieNode;\r\n\r\n    constructor() {\r\n        this._node = { handlers: new Array<Function>() };\r\n    }\r\n\r\n    private _on(args: any[], handler: Function): Subscription {\r\n        let node = this._node;\r\n        for (let i = 0; i < args.length; ++i) {\r\n            if (node.children === void 0) {\r\n                node.children = new _Map<any, TrieNode>();\r\n            }\r\n            let child = node.children.get(args[i]);\r\n            if (child === void 0) {\r\n                child = { handlers: new Array<Function>() };\r\n                node.children.set(args[i], child);\r\n            }\r\n            node = child;\r\n        }\r\n        node.handlers.push(handler);\r\n        return new EmitterSubscription(this._node, args, handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    on(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        return this._on(args.slice(0, lastIndex), handler);\r\n    }\r\n\r\n    /**\r\n     * Subscribe to some event from this Emitter. Subscription will be disposed after single handler call.\r\n     * @param args Array: sequence of event prefixes and event handler function at last position\r\n     * @returns Subscription: created subscription to event\r\n     */\r\n    once(...args: Array<any | Function>): Subscription {\r\n        const lastIndex = arguments.length - 1;\r\n        if (lastIndex < 0) {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const handler = args[lastIndex] as Function;\r\n        if (typeof handler !== \"function\") {\r\n            throw new Error(\"last argument is not a function\");\r\n        }\r\n        const subscription = this._on(args.slice(0, lastIndex), (...args: any[]) => {\r\n            subscription.dispose();\r\n            handler(...args);\r\n        });\r\n        return subscription;\r\n    }\r\n\r\n    /**\r\n     * Emit one event.\r\n     * @param args Array: event prefixes then event arguments\r\n     */\r\n    emit(...args: any[]): void {\r\n        let node = this._node;\r\n        let handlers = node.handlers;\r\n        let hInd = handlers.length;\r\n        while (hInd--) {\r\n            handlers[hInd].apply(void 0, args);\r\n        }\r\n        let arg: any;\r\n        let aInd = args.length;\r\n        while (node.children !== void 0 && aInd--) {\r\n            arg = args.shift();\r\n            node = node.children.get(arg);\r\n            if (node === void 0) {\r\n                return;\r\n            }\r\n            handlers = node.handlers;\r\n            hInd = handlers.length;\r\n            while (hInd--) {\r\n                handlers[hInd].apply(void 0, args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface Handler {\r\n    emitter: PrefixEmitter;\r\n    args: any[];\r\n    key: string | symbol;\r\n    once?: boolean;\r\n}\r\n\r\nconst _handlers = _Symbol(\"__prefix_emitter_handlers_\");\r\nconst _subscriptions = _Symbol(\"__prefix_emitter_subscriptions_\");\r\n\r\n// overloads for different interfaces\r\nexport function on(emitter: VoidEmitter): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function on<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function on<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @on(emitter, \"event\")\r\n *     eventHandler(arg: any) { }\r\n * }\r\n */\r\nexport function on(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key });\r\n    };\r\n}\r\n\r\n\r\n// overloads for different interfaces\r\nexport function once(emitter: VoidEmitter): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>): MethodDecorator;\r\nexport function once<T>(emitter: SingleEmitter<T>, arg: T): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent): MethodDecorator;\r\nexport function once<TEvent, TArg>(emitter: DoubleEmitter<TEvent, TArg>, event: TEvent, arg: TArg): MethodDecorator;\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator;\r\n\r\n/**\r\n * Method Decorator for subscribe to Emitter at some prefix described by rest parameters.\r\n * Subscription will be disposed after single method call.\r\n * @param emitter PrefixEmitter: some emitter\r\n * @param args Array: sequence of event prefixes\r\n * @example\r\n * class Component {\r\n *     @once(emitter, \"event\")\r\n *     selfDisposingHandler(arg: any) { }\r\n * }\r\n */\r\nexport function once(emitter: PrefixEmitter, ...args: any[]): MethodDecorator {\r\n    return (target: Object, key: string | symbol) => {\r\n        let handlers: Handler[] = target[_handlers];\r\n        if (handlers === void 0) {\r\n            target[_handlers] = handlers = new Array<Handler>();\r\n        } else if (!target.hasOwnProperty(_handlers)) {\r\n            target[_handlers] = handlers = [...handlers];\r\n        }\r\n        handlers.push({ emitter, args, key, once: true });\r\n    };\r\n}\r\n\r\n/**\r\n * Class Decorator for injecting subscriptions defined by `@on` and `@once` annotations during constructor call.\r\n * @example\r\n * @injectSubscriptions\r\n * class Component {\r\n *     constructor() { }\r\n * }\r\n */\r\nexport function injectSubscriptions<TConstructor extends Function>(target: TConstructor): TConstructor;\r\n\r\n/**\r\n * Method Decorator for injecting subscriptions defined by `@on` and `@once` annotations during method call.\r\n * @example\r\n * class Component {\r\n *     @injectSubscriptions\r\n *     componentDidMount() { }\r\n * }\r\n */\r\nexport function injectSubscriptions(target: Object, key: string | symbol): void;\r\n\r\n/**\r\n * Utility function for injecting subscriptions defined by `@on` and `@once` annotations.\r\n * @example\r\n * class Component {\r\n *     componentDidMount() {\r\n *         injectSubscriptions(this);\r\n *     }\r\n * }\r\n */\r\nexport function injectSubscriptions(target: Object): void;\r\n\r\nexport function injectSubscriptions(\r\n    target: Function | Object, key?: string | symbol,\r\n    descriptor?: TypedPropertyDescriptor<Function>\r\n): TypedPropertyDescriptor<Function> | Function | void {\r\n    if (arguments.length === 3) { // ES5+ method decorator\r\n        descriptor = descriptor || Object.getOwnPropertyDescriptor(target, key);\r\n        descriptor.value = decorateMethod(descriptor.value, logic);\r\n        return descriptor;\r\n    } else if (arguments.length === 2) { // ES3 method decorator\r\n        target[key] = decorateMethod(target[key], logic);\r\n        return;\r\n    } else if (target instanceof Function) { // constructor decorator\r\n        return decorateClass(target, logic);\r\n    } else { // explicit invocation\r\n        logic.call(target);\r\n        return;\r\n    }\r\n\r\n    function logic() {\r\n        const handlers: Handler[] = this[_handlers];\r\n        if (handlers !== void 0 && !this.hasOwnProperty(_subscriptions)) {\r\n            this[_subscriptions] = handlers.map(h => {\r\n                const method: Function = this[h.key].bind(this);\r\n                return h.once\r\n                    ? h.emitter.once(...h.args, method)\r\n                    : h.emitter.on(...h.args, method);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Method Decorator for disposing all injected subscriptions during method call.\r\n * @example\r\n * class Component {\r\n *     @disposeSubscriptions\r\n *     componentWillUnmount() { }\r\n * }\r\n */\r\nexport function disposeSubscriptions(target: Object, key: string | symbol): void;\r\n\r\n/**\r\n * Utility function for disposing all injected subscriptions.\r\n * @example\r\n * class Component {\r\n *     componentWillUnmount() {\r\n *         disposeSubscriptions(this);\r\n *     }\r\n * }\r\n */\r\nexport function disposeSubscriptions(target: Object): void;\r\n\r\nexport function disposeSubscriptions(\r\n    target: Object, key?: string | symbol,\r\n    descriptor?: TypedPropertyDescriptor<Function>\r\n): TypedPropertyDescriptor<Function> | Function | void {\r\n    if (arguments.length === 3) { // ES5+ method decorator\r\n        descriptor = descriptor || Object.getOwnPropertyDescriptor(target, key);\r\n        descriptor.value = decorateMethod(descriptor.value, logic);\r\n        return descriptor;\r\n    } else if (arguments.length === 2) { // ES3 method decorator\r\n        target[key] = decorateMethod(target[key], logic);\r\n    } else { // explicit invocation\r\n        logic.call(target);\r\n    }\r\n\r\n    function logic() {\r\n        const subscriptions: Subscription[] = this[_subscriptions];\r\n        if (subscriptions !== void 0) {\r\n            subscriptions.forEach(s => { s.dispose(); });\r\n            delete this[_subscriptions];\r\n        }\r\n    }\r\n}"],"names":["array","item","index","indexOf","splice","shift","count","template","sep","arr","i","push","join","target","source","k","hasOwnProperty","logic","pr","factory","Function","name","repeat","length","constructor","prototype","assign","key","Error","emitter","_i","args","handlers","_handlers","Array","once","descriptor","this","_subscriptions","map","h","method","_this","bind","_a","_b","on","arguments","Object","getOwnPropertyDescriptor","value","decorateMethod","decorateClass","call","subscriptions","forEach","s","dispose","l","create","MapFallback","_store","size","_Map","Map","_Symbol","Symbol","SymbolFallback","node","handler","_node","_args","_handler","_disposed","EmitterSubscription","removeItem","nodeChain","children","get","_cleanupTrie","parent","delete","PrefixEmitter","child","set","lastIndex","_on","slice","subscription","hInd","apply","arg","aInd"],"mappings":"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"}